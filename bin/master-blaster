#!/usr/bin/env python

# Master Blaster - Rename Primary Branches Of Code Repositories
# Copyright (C) 2020 Gareth Field - field.gareth @ gmail.com

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import json
import logging
import os
from pathlib import Path
import questionary
import requests
import subprocess
import sys

# This defaults to v3 of the api.
GITHUB_API = "https://api.github.com"

# * ``` Intro text! ``` * #
intro = """
  Welcome to master-blaster! This program renames primary branches for GitHub users!
  We'll go through the options before making any changes!
"""
print(intro)

# * ``` License text! ``` * #
licenseText = """
    master-blaster  Copyright (C) 2020  Gareth Field
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.
"""
print(licenseText)
print("Working on `show w' and `show c', actually! It's GNU public 3+! No closed versions!")

# * ``` Explanation of token thing! ``` * #
tokenExplanation = """
  GitHub is deprecating password-based token generation! This is great for
  security, it's going to mean you're going to have to go to GitHub.com and
  come back with an access token to make this program work, though. The next
  question will determine whether the program needs a token with the more
  general `repo` scope or the more limited `public_repo` scope. You can run
  this program again if you're happy with the results!
"""
print(tokenExplanation)

# * ``` Write to a new or existing log file! ``` * #
# ! Testing! #
# filemode='w' will not append to the file, it'll write over
logging.basicConfig(filename='info.log', filemode='w',
                    level=logging.INFO, format='%(asctime)s %(message)s')
print("""
    Log file found at ./info.log!
""")
logging.info("Creating a log file!!")

# * ~~~  Username gathering! ~~~ * #

# * ``` Placeholder variable for the username! ``` * #
username = ""

# * ``` Ask for username! ``` * #
usernamePrompt = """
  Please enter your GitHub username!
"""


def usernameConfirmationPrompt(usernameInput):
    return f"GitHub username: {usernameInput}?"


# ! Testing ! #
usernameConfirmed = False
while not usernameConfirmed:
    usernameResponse = questionary.text(usernamePrompt).ask()
    if usernameResponse == "":
        print("GitHub username blank: Please try again!")
        continue
    if len(usernameResponse) >= 40:
        print("GitHub usernames are 39 chars or less: please try again!")
        continue
    else:
        usernameConfirmationResponse = questionary.confirm(
            usernameConfirmationPrompt(usernameResponse)).ask()
        if usernameConfirmationResponse == False:
            print("Retry!")
            continue
        if usernameConfirmationResponse:
            username = usernameResponse
            usernameConfirmed = True
            continue


# ! Testing ! #
username = "Twitchkidd"

# * ~~~ Set of questionary dictionary questions! ~~~ * #

# * ``` Placeholder variable for repo types!``` * #
repoTypes = ""

# * ``` What types of repos! ``` * #

# * ``` Question ``` * #
repoTypesPrompt = """
  What set of repositories do you want to update?
"""

# * ``` Choices ``` * #
repoTypesAll = "All repositories I'm the owner, collaborator, and/or organization member, public and private."
repoTypesAllPublic = "All repositories I'm the owner, collaborator, and/or organization member, only public, not private."
repoTypesOwner = "All repositories I'm the owner of, public and private."
repoTypesOwnerPublic = "All repositories I'm the owner of, only public, not private."
repoTypesCollaborator = "All repositories I'm the owner of and/or a collaborator on, public and private."
repoTypesCollaboratorPublic = "All repositories I'm the owner of and/or a collaborator on, only public, not private."
repoTypesOrganization = "All repositories I'm the owner of and/or a member of the organization, public and private."
repoTypesOrganizationPublic = "All repositories I'm the owner of and/or a member of the organization, only public, not private."

# * ``` What to name the primary branches and choices! ``` * #

# * ``` Question ``` * #
namesSelectionPrompt = """
  What would you like to call your primary branches? (Default 'main'.)
"""

# * ``` Choices ``` * #
namesMain = "All primary branches renamed to 'main'."
namesCustom = "Choose another name to rename all primary branches to."
namesPerRepo = "Interactively choose a name for the primary branch for each repo."

questions = [
    {
        "type": "select",
        "name": "repoTypes",
        "message": repoTypesPrompt,
        "choices": [
            repoTypesAll,
            repoTypesAllPublic,
            repoTypesOwner,
            repoTypesOwnerPublic,
            repoTypesCollaborator,
            repoTypesCollaboratorPublic,
            repoTypesOrganization,
            repoTypesOrganizationPublic
        ]
    },
    {
        "type": "select",
        "name": "namesSelection",
        "message": namesSelectionPrompt,
        "choices": [
            "All primary branches renamed to 'main'.",
            "Choose another name to rename all primary branches to.",
            "Interactively choose a name for the primary branch for each repo."
        ]
    }
]

# * ``` Extract the data from the set of prompts from dictionary! ``` * #
answers = questionary.prompt(questions)
repoTypes = answers['repoTypes']
logging.info(f"Repository types chosen: {repoTypes}")
logging.info(f"Naming selection: {answers['namesSelection']}")

# * ~~~ Custom primary branch flow! ~~~ * #

# * ``` Placeholder variable for the primary branch name! ``` * #
name = "main"

# * ``` Custom name for all branches! ``` * #
customNamePrompt = """
  What name are you choosing for primary branches?
"""

# * ``` Confirm reset to main! ``` * #
confirmResetToMainPrompt = """
    Default: use 'main' for all primary branches?
"""


def customNameConfirmPrompt(inputName):
    return f'''{inputName} for all primary branches?'''


if answers['namesSelection'] == "Choose another name to rename all primary branches to.":
    nameConfirmed = False
    while not nameConfirmed:
        customNameResponse = questionary.text(customNamePrompt).ask()
        if customNameResponse == "":
            confirmResetToMainResponse = questionary.confirm(
                confirmResetToMainPrompt).ask()
            if confirmResetToMainResponse:
                name = "main"
                nameConfirmed = True
                logging.info(f"Name for primary branches: {name}")
            else:
                continue
        else:
            confirmCustomNameResponse = questionary.confirm(
                customNameConfirmPrompt(customNameResponse)).ask()
            if confirmCustomNameResponse:
                name = customNameResponse
                nameConfirmed = True
                logging.info(f"Name for primary branches: {name}")
                pass

# * ~~~ Interactive naming mode choice handling! ~~~ * #

# * ``` Placeholder variable for interactive naming mode! ``` * #
interactive = False

# * ``` Confirmation that interactive naming mode will happen! ``` * #
interactiveNamingConfirmationPrompt = """
    Okay! We'll name them after we fetch the set of repos!
"""

if answers['namesSelection'] == "Interactively choose a name for the primary branch for each repo.":
    interactive = True
    print(interactiveNamingConfirmationPrompt)

# * ~~~ Local directory choice handling! ~~~ * #

# * ``` Local directory yay or nay! ``` * #
localDirectoriesPrompt = """
  Repositories not present locally will be cloned to a temporary folder,
  updated, the update pushed, (the default branch on GitHub.com updated,)
  and then deleted locally. We can decrease the use of bandwidth and reduce
  potential conflicts by scanning for repositories that *are* present locally.
  Is this okay? (No other changes will be added or committed.)
"""
localDirectories = questionary.confirm(localDirectoriesPrompt).ask()

# * ``` Placeholder variable for local directory selection! ``` * #
localDirectory = Path.home()

# * ``` Which local directory? ``` * #
localDirectoryPrompt = """
    Do you keep your projects in a certain directory? Type that in here to
    speed up search! Like /Users/gareth/Code ... default is ~/, hit enter for default.
"""

# * ``` Confirm reset to home! ``` * #
confirmResetToHomePrompt = """
    Default: use '~/' for local directory search?
"""


def customLocalDirectoryConfirmPrompt(inputDir):
    return f'''{inputDir} for all primary branches?'''


if localDirectories:
    localDirectoryConfirmed = False
    while not localDirectoryConfirmed:
        customLocalDirectoryResponse = questionary.text(
            localDirectoryPrompt).ask()
        if customLocalDirectoryResponse == "":
            confirmResetToHomeResponse = questionary.confirm(
                confirmResetToHomePrompt).ask()
            if confirmResetToHomeResponse:
                localDirectory = Path.home()
                localDirectoryConfirmed = True
                logging.info(f"Local directory to search: {localDirectory}")
            else:
                continue
        else:
            confirmCustomLocalDirectoryResponse = questionary.confirm(
                customLocalDirectoryConfirmPrompt(customLocalDirectoryResponse)).ask()
            if confirmCustomNameResponse:
                localDirectory = customLocalDirectoryResponse
                localDirectoryConfirmed = True
                logging.info(f"Local directory to search: {localDirectory}")
                pass

# ! TESTING # !!
localDirectory = f"{Path.home()}/Code"

# * ~~~ New Git Alias! ~~~ * #

# * ``` Placeholder variable for git alias selection! ``` * #
gitNew = False

# * ``` Prompt! ``` * #
gitNewPrompt = f"""
    We can add a git alias 'git new' that initializes new git repos with HEAD as
    '{name}', shall we?
"""

# * ``` Ask it! ``` * #
if not interactive:
    gitNew = questionary.confirm(gitNewPrompt)
    # * ``` Log the choice! ``` * #
    logging.info(f"Add git alias `git new`: {name}")


# * ~~~ Token Time! ~~~ * #

# * ``` Placeholder variables for the token! ``` * #
token = ""

# ! ``` Placeholder variables for the testing tokens! ``` ! #
# ! Testing! #
tokenRepoScope = ""
tokenPublicRepoScope = ""

# ! Testing! #
with open("./repo.txt", 'r') as repoF:
    tokenRepoScope = repoF.read(40)

# ! Testing! #
with open("./repoPublicRepo.txt", 'r') as repoPublicRepoF:
    tokenPublicRepoScope = repoPublicRepoF.read(40)

tokenType = ""
# try any again?
if repoTypes == "All repositories I'm the owner, collaborator, and/or organization member, public and private." or repoTypes == "All repositories I'm the owner of, public and private." or repoTypes == "All repositories I'm the owner of and/or a collaborator on, public and private." or repoTypes == "All repositories I'm the owner of and/or a member of the organization, public and private.":
    tokenType = "repo"
else:
    tokenType = "public repo"


def tokenPrompt(tokenTypeArg):
    return f"""
        Last step! Since password-based token generation is being deprecated, please
        get a personal access token with the correct scope(s) in order to run this
        program. To get this token, go to https://github.com, sign in, then go to
        'Settings', then 'Developer Settings', then 'Personal access tokens', then
        'Generate new token', confirm your password, name the token in the 'Note'
        input field, and select the {tokenTypeArg} scope, then 'Generate Token', then
        copy it to your clipboard and either paste it back here into the prompt, or
        save it first in case there's an error and you need to retry. (Recommended)
    """


def getToken():
    tokenConfirmed = False
    while not tokenConfirmed:
        customTokenResponse = questionary.text(tokenPrompt(tokenType)).ask()
        if customTokenResponse == "":
            print("Please enter the token!")
            continue
        else:
            token = customTokenResponse
            tokenConfirmed = True
            continue
    # ! Testing! #
    # token = "fermf"
    token = tokenRepoScope
    print(token)
    return token


# * ``` Constructing the url! ``` * #


def constructReposUrl():
    return f"{GITHUB_API}/user/repos"

# * ``` Construct the headers! ``` * #


def constructHeaders(token):
    headers = {"Authorization": 'token ' + token}
    return headers

# * ``` Custruct the parameters! ``` * #


def constructReposParams():
    params = {}
    if repoTypes == repoTypesAll:
        params = {"per_page": "1000"}
    if repoTypes == repoTypesAllPublic:
        params = {"per_page": "1000", "visibility": "public"}
    if repoTypes == repoTypesOwner:
        params = {"per_page": "1000", "type": "owner"}
    if repoTypes == repoTypesOwnerPublic:
        params = {"per_page": "1000", "visibility": "public", "type": "owner"}
    if repoTypes == repoTypesCollaborator:
        params = {"per_page": "1000", "type": "owner,collaborator"}
    if repoTypes == repoTypesCollaboratorPublic:
        params = {"per_page": "1000", "visibility": "public",
                  "type": "owner,collaborator"}
    if repoTypes == repoTypesOrganization:
        params = {"per_page": "1000",
                  "type": "owner,collaborator,organization_member"}
    if repoTypes == repoTypesOrganizationPublic:
        params = {"per_page": "1000", "visibility": "public",
                  "type": "owner,collaborator,organization_member"}
    return params


# * ``` Placeholder variable for the total set of repos! ``` * #
repos = []

# * ``` Ask for the token until the response comes back okay, then extract the data from the API call! ``` * #
reposResponseConfirmed = False
while not reposResponseConfirmed:
    token = getToken()
    url = constructReposUrl()
    params = constructReposParams()
    headers = constructHeaders(token)
    print("Sending network request ...")
    reposResponse = requests.get(url, params=params, headers=headers)
    # Bad token returns a 401! #
    if reposResponse.status_code >= 400:
        logging.warning(f"Response status: {reposResponse.status_code}")
        print(
            f"Network error! Possibly the token! Try again please! If this is not your GitHub username, please restart the program: {username}")
        continue
    else:
        print("Got the network request!")
        reposResponseConfirmed = True
        for repository in reposResponse.json():
            repos.append(
                {"defaultBranch": repository['default_branch'], "htmlUrl": repository['html_url'], "name": repository['name'], "owner-login": f"{repository['owner']['login']}", "primaryBranchName": name})
        pass


# * If they wanted to name each primary branch, do so now! * #
if interactive:
    print("""
        Interactive naming mode!
    """)
    for repo in repos:
        primaryBranchNameConfirmed = False
        while not primaryBranchNameConfirmed:
            repoNameResponse = questionary.text(
                f"Primary branch name for {repo['htmlUrl']}?").ask()
            if repoNameResponse == "":
                defaultNameResponse = questionary.confirm(
                    f"Default primary branch name {name} for {repo['htmlUrl']}?")
                if defaultNameResponse:
                    logging.info(
                        f"Primary branch name for {repo['htmlUrl']}: {name}")
                    primaryBranchNameConfirmed = True
                    continue
                else:
                    continue
            else:
                customRepoNameConfirmed = questionary.confirm(
                    f"{repoNameResponse} for {repo['htmlUrl']}?")
                if customRepoNameConfirmed:
                    primaryBranchNameConfirmed = True
                    repo['primaryBranchName'] = repoNameResponse
                    logging.info(
                        f"Primary branch name for {repo['htmlUrl']}: {repoNameResponse}")
                    continue
                else:
                    pass


# * ~~~ Take all these repos and test them against what the name is supposed to be! ~~~ * #

# * ``` Construct the url! ``` * #
def constructBranchesUrl(repo, which):
    return f"{GITHUB_API}/repos/{repo['owner-login']}/{repo['name']}/branches/{which}"


for repo in repos:
    primaryBranchUrl = constructBranchesUrl(repo, repo['primaryBranchName'])
    masterBranchUrl = constructBranchesUrl(repo, "master")
    headers = constructHeaders(token)
    print("Sending network request ...")
    print("Sending network request ...")
    primaryBranchResponse = requests.get(primaryBranchUrl, headers=headers)
    masterBranchResponse = requests.get(masterBranchUrl, headers=headers)
    print("Got the network request!")
    print("Got the network request!")
    if primaryBranchResponse.json().get('message'):
        repo['hasPrimaryBranchName'] = False
    if masterBranchResponse.json().get('message'):
        repo['hasMasterBranch'] = False
    if primaryBranchResponse.json().get('name'):
        repo['hasPrimaryBranchName'] = True
    if masterBranchResponse.json().get('name'):
        repo['hasMasterBranch'] = True


# * ~~~ If they wanted to use local clones, look for them! ~~~ * #

# * ``` Placeholder variable for the set of local repos! ``` * #
localRepos = []


def getLocalRepoUrl(configFile):
    url = ""
    for line in configFile:
        if line.find('url =') != -1:
            remoteOriginUrlStart = line.find('url =')
            url = line[remoteOriginUrlStart + 6:-1]
            return url


if localDirectories:
    repoNames = [repo['name'] for repo in repos]
    for root, subdirs, files in os.walk(f"{localDirectory}"):
        for subdir in subdirs:
            if any(subdir == repoName for repoName in repoNames):
                try:
                    with open(f"{root}/{subdir}/.git/config", "r") as configFile:
                        localRepos.append(
                            {"url": getLocalRepoUrl(configFile), "path": f"{root}/{subdir}"})
                except Exception as err:
                    # print(f"Exception: {err}")
                    pass

# * ~~~ Change the branches! ~~~ * #

# * ``` The set of local repo origin urls! ``` * #
localRepoUrls = [localRepo['url'] for localRepo in localRepos]

# * ``` Placeholder variables for groups of checked repos! ``` * #
reposWithErrors = []
reposReadyForLocal = []
reposReadyForRemote = []


def check(repo):
    if repo.get('localHasMaster'):
        if repo['localHasMaster'] and not repo['localHasPrimaryBranchName']:
            if repo['hasMasterBranch'] and not repo['hasPrimaryBranchName'] and not repo['defaultBranch'] == "master":
                repo['status'] = "error: not ready for remote process, default branch of remote isn't master"
                reposWithErrors.append(repo)
            elif repo['hasPrimaryBranchName'] and not repo['hasMasterBranch'] and not repo['defaultBranch'] == repo['primaryBranchName']:
                repo['status'] = "error: not ready for local process, default branch of remote isn't the primary branch name"
                reposWithErrors.append(repo)
            elif repo['hasMasterBranch'] and repo['hasPrimaryBranchName']:
                repo['status'] = "error: not ready for remote process, remote has a branch with the primary branch name already"
                reposWithErrors.append(repo)
            elif not repo['hasMasterBranch'] and not repo['hasPrimaryBranchName']:
                repo['status'] = "error: not ready for remote process, remote doesn't have a master branch"
                reposWithErrors.append(repo)
            elif repo['hasMasterBranch'] and not repo['hasPrimaryBranchName'] and repo['defaultBranch'] == "master":
                repo['status'] = "ready for remote process"
                reposReadyForRemote.append(repo)
            elif repo['hasPrimaryBranchName'] and not repo['hasMasterBranch'] and repo['defaultBranch'] == repo['primaryBranchName']:
                repo['status'] = "ready for local process"
                reposReadyForLocal.append(repo)
            else:
                repo['status'] = "error: unknown error"
                reposWithErrors.append(repo)
        else:
            if (not repo['localHasMaster'] and not repo['localHasPrimaryBranchName']) or (repo['localHasMaster'] and repo['localHasPrimaryBranchName']):
                repo['status'] = "error: local repository branching not ready"
                reposWithErrors.append(repo)
            else:
                repo['status'] = "error: unknown error"
                reposWithErrors.append(repo)
    else:
        if repo['hasMasterBranch'] and not repo['hasPrimaryBranchName'] and not repo['defaultBranch'] == "master":
            repo['status'] = "error: not ready for remote process, default branch of remote isn't master"
            reposWithErrors.append(repo)
        elif repo['hasMasterBranch'] and repo['hasPrimaryBranchName']:
            repo['status'] = "error: not ready for remote process, remote has a branch with the primary branch name already"
            reposWithErrors.append(repo)
        elif not repo['hasMasterBranch'] and not repo['hasPrimaryBranchName']:
            repo['status'] = "error: not ready for remote process, remote doesn't have a master branch"
            reposWithErrors.append(repo)
        elif repo['hasMasterBranch'] and not repo['hasPrimaryBranchName'] and repo['defaultBranch'] == "master":
            repo['status'] = "ready for remote process"
            reposReadyForRemote.append(repo)
        else:
            repo['status'] = "error: unknown error"
            reposWithErrors.append(repo)


if localDirectories:
    for repo in repos:
        if repo['htmlUrl'] in localRepoUrls:
            localPath = ""
            for localRepo in localRepos:
                if localRepo['url'] == repo['html']:
                    localPath = localRepo['path']
            subprocess.run(["cd", f"{localPath}"], universal_newlines=True,
                           stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            result = subprocess.run(["git", "branch"], universal_newlines=True,
                                    stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            repo['localHasMaster'] = "master" in result.stdout
            repo['localHasPrimaryBranchName'] = repo['primaryBranchName'] in result.stdout
            check(repo)
        else:
            check(repo)
else:
    for repo in repos:
        check(repo)

# * ``` Placeholder variable for local and remote processes being a go! ``` * #
localIsAGo = False
remoteIsAGo = False


def localProcess(repo):
    for localRepo in localRepos:
        if repo['htmlUrl'] == localRepo['url']:
            subprocess.run(["cd", localRepo['path']], universal_newlines=True,
                           stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            subprocess.run(["git", "checkout", "master"], universal_newlines=True,
                           stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            subprocess.run(["git", "branch", "-m", "master", repo['primaryBranchName']], universal_newlines=True,
                           stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            subprocess.run(["git", "fetch"], universal_newlines=True,
                           stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            subprocess.run(["git", "branch", "--unset-upstream"], universal_newlines=True,
                           stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            subprocess.run(["git", "branch", "-u", f"origin/{repo['primaryBranchName']}"],
                           universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            subprocess.run(["git", "symbolic-ref", "refs/remotes/origin/HEAD",
                            f"refs/remotes/origin/{repo['primaryBranchName']}"], universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)


def constructPatchDefaultUrl(repo):
    return f"{GITHUB_API}/repos/{username}/{repo['name']}"


def remoteProcess(repo):
    if localDirectories:
        if repo['htmlUrl'] in localRepoUrls:
            for localRepo in localRepos:
                if repo['htmlUrl'] == localRepo['url']:
                    subprocess.run(["cd", localRepo['path']], universal_newlines=True,
                                   stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                    subprocess.run(["git", "branch", "-m", "master", repo['primaryBranchName']],
                                   universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                    subprocess.run(["git", "push", "-u", "origin", repo['primaryBranchName']],
                                   universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                    print(
                        f"Primary branch for {repo['htmlUrl']} updated to {repo['primaryBranchName']}.")
                    logging.info(
                        f"Primary branch for {repo['htmlUrl']} updated to {repo['primaryBranchName']}.")
        subprocess.run(["cd", localDirectory], universal_newlines=True,
                       stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        subprocess.run(["git", "clone", f"{repo['htmlUrl']}.git", f"{localDirectory}/{repo['owner-login']}/{repo['name']}"],
                       universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        subprocess.run(["cd", f"{localDirectory}/{repo['owner-login']}/{repo['name']}"],
                       universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        subprocess.run(["git", "branch", "-m", "master", repo['primaryBranchName']],
                       universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        subprocess.run(["git", "push", "-u", "origin", repo['primaryBranchName']],
                       universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        print(
            f"Primary branch for {repo['htmlUrl']} updated to {repo['primaryBranchName']}.")
        logging.info(
            f"Primary branch for {repo['htmlUrl']} updated to {repo['primaryBranchName']}.")
    else:
        subprocess.run(["cd", localDirectory], universal_newlines=True,
                       stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        subprocess.run(["git", "clone", f"{repo['htmlUrl']}.git", f"{localDirectory}/{repo['owner-login']}/{repo['name']}"],
                       universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        subprocess.run(["cd", f"{localDirectory}/{repo['owner-login']}/{repo['name']}"],
                       universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        subprocess.run(["git", "branch", "-m", "master", repo['primaryBranchName']],
                       universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        subprocess.run(["git", "push", "-u", "origin", repo['primaryBranchName']],
                       universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        print(
            f"Primary branch for {repo['htmlUrl']} updated to {repo['primaryBranchName']}.")
        logging.info(
            f"Primary branch for {repo['htmlUrl']} updated to {repo['primaryBranchName']}.")
    url = constructPatchDefaultUrl(repo)
    params = json.dumps({"default_branch": {repo['primaryBranchName']}})
    patchDefaultResponse = requests.patch(url, params=params, headers=headers)
    if patchDefaultResponse.status_code >= 400:
        logging.warning(f"Response status: {patchDefaultResponse.status_code}")
        print(
            f"Network error! Status code: {patchDefaultResponse.status_code}, message: {[responseJson['message'] for responseJson in patchDefaultResponse.json()][0]}")
    else:
        print(
            f"Default branch for {repo['htmlUrl']} updated to {repo['primaryBranchName']}.")
        logging.info(
            f"Default branch for {repo['htmlUrl']} updated to {repo['primaryBranchName']}.")


if len(reposWithErrors) > 0:
    print("The following repos had errors that prevented any process to run on them:")
    for repo in reposWithErrors:
        print(repo['htmlUrl'])
        print(repo['status'])

if len(reposReadyForLocal) > 0:
    print("The following repos are ready to update primary branch and origin locally:")
    for repo in reposReadyForLocal:
        print(repo['htmlUrl'])
    localIsAGo = questionary.confirm("Continue?")

if len(reposReadyForRemote) > 0:
    print("The following repos are ready to update the primary branch:")
    for repo in reposReadyForRemote:
        print(repo['htmlUrl'])
    remoteIsAGo = questionary.confirm("Continue?")
    if not remoteIsAGo:
        print("Okay! It's a no-go for remote repos!")


if localIsAGo:
    for repo in reposReadyForLocal:
        localProcess(repo)

if remoteIsAGo:
    for repo in reposReadyForRemote:
        remoteProcess(repo)

# * Add the `git new` alias! * #
if gitNew:
    if interactive:
        print("Interactive mode enabled, so no one name for `git new`!")
        break
    subprocess.run(["git", "config", "--global", "alias.new", "'!git", "init"], universal_newlines=True,
                   stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    subprocess.run(["git", "symbolic-ref", "HEAD", f"refs/heads/{name}"], universal_newlines=True,
                   stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    print(
        f"Git alias `git new` created to initialize repos with the HEAD ref at {name}")
    logging.info(
        f"Git alias `git new` created to initialize repos with the HEAD ref at {name}")

if not remoteIsAGo:
    sys.exit(1)

if len(reposReadyForLocal) > 0:
    print(f"{len(reposReadyForLocal)} local repos updated!")

if len(reposReadyForRemote) > 0:
    print(f"{len(reposReadyForRemote)} repos updated!")

print("Check the log file at ./info.log for details!")
print("Thank you for using master-blaster!")
