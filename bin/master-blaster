#!/usr/bin/env python

# Master Blaster - Rename Primary Branches Of Code Repositories
# Copyright (C) 2020 Gareth Field - field.gareth @ gmail.com

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# import questionary
# from pathlib import Path
import requests
# import getpass
import json
from urllib.parse import urljoin

GITHUB_API = "https://api.github.com"

testToken = "1036c7cd7bed6bb17f5380ae57ae741002c49266"

url = urljoin(GITHUB_API, 'authorizations')
res = requests.get(

)
print(res.json())

# requests.patch is a thing!

# init = '''
# Welcome to master-blaster! This program automatically renames primary branches
# from master to main for GitHub users!
# '''

# username = input("GitHub username: ")
# password = getpass.getpass("GitHub password: ")

# url = urljoin(GITHUB_API, 'authorizations')
# payload = {}

# res = requests.post(
#     url,
#     auth=(username, password),
#     data=json.dumps(payload)
# )

# j = json.loads(res.text)
# if res.status_code >= 400:
#     msg = j.get('message', "UNDEFINED ERROR (no error description from server)")
#     print(f"Error: {msg}")
#     exit()
# token = j["token"]
# print(f"Token : {token}")

# answer = questionary.select(
#     "prompt",
#     choices=[
#         "Option 1",
#         "Option 2",
#         "Option 3"
#     ]
# ).ask()
# prompt = "Check ~/.gitconfig for your GitHub email? "
# checkGitconfig = input(prompt)
# print(checkGitconfig)
# email = ""
# emailStringStart = 0
# if checkGitconfig == "Yes":
#     print("Okay\n")
#     with open(f"{Path.home()}/.gitconfig", 'r') as f:
#         # gitconfig = f.read()
#         # print(gitconfig)
#         found = False
#         for line in f:
#             if line.find("email =") != -1:
#                 print(line)
#                 found = True
#                 emailStringStart = line.find("email =")
#                 print(line[emailStringStart + 8:])
#         if found == False:
#             print("Can't find email!")
# Uhh so, turns out you can't search by email, as that's not a public thing. Wah wah. Lots to learn.
# So username is what we're looking for ... and how to generate an oauth token? I was looking at
# oauth apps, but you can just hit the rest api with an authorization header that's an oauth token

# Oh thank the l ... thanks Jason McVetta!!! https://advanced-python.readthedocs.io/en/latest/rest/authtoken.html

# Oh, fuck me! GitHub is nuking password-based token generation! Doesn't work without 2FA! UMMM okay, either
# ask the user to generate a token manually or launch a browser somehow?!


# Okay so we'll need something explaining what you need to come back to the terminal with
# and an input it paste in the token
# and then the rest of the questions which go
# username
# types of repos ... actually does that need to go in before the ... yea, because you need
# to explain what scope to allow ...
# yea lets see, scope ... so ...
# username,
# what types of repos ... so it looks like either `repo` or `public_repo`
# I guess I don't need to go crazy with specification of single or multiple contributer-type stuff yet
# then when you have username and what scopes to ask for, then ... ping for the list, and if
# that goes wrong there was either a username or scope issue, and for the moment just close the process?
# Okay well once you get a list, then ask about what to name the main branches, and say you'll ask that
# beforehand ... and then ask for permission to scan for local repos, warn about committing everything,
# and then do the thing, lol.

# GET /user/repos

# visibility? => all ~ public ~ private
# affiliation? => owner ~ collaborator ~ organization_member
# type? => all ~ owner ~ public ~ private ~ member (422 error if collision with previous)

# PATCH /repos/:owner/:repo
# default_branch? string

# HHMMMM
# __main__ — Top-level script environment¶
# '__main__' is the name of the scope in which top-level code executes. A module’s __name__ is set equal to '__main__' when read from standard input, a script, or from an interactive prompt.

# A module can discover whether or not it is running in the main scope by checking its own __name__, which allows a common idiom for conditionally executing code in a module when it is run as a script or with python -m but not when it is imported:

# if __name__ == "__main__":
#     # execute only if run as a script
#     main()
# For a package, the same effect can be achieved by including a __main__.py module, the contents of which will be executed when the module is run with -m.

# headers = {"user-agent": "my-app-101"}
# payload = { "key1": "Value1", "key2": "Value2"}
# r = requests.whatever("url://something", params=payload)
