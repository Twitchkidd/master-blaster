#!/usr/bin/env python

# Master Blaster - Rename Primary Branches Of Code Repositories
# Copyright (C) 2020 Gareth Field - field.gareth @ gmail.com

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# * A log file should be created, data should be put in that would be useful, and mention of it should be made to the user both inline and in the docs. * #

import json
import logging
import os
from pathlib import Path
import questionary
import requests
import subprocess
import sys

# This defaults to v3 of the api.
GITHUB_API = "https://api.github.com"

# * ``` Placeholder variable for the name and interactive naming mode! ``` * #
name = "main"
interactive = False

# * ``` Choosing a custom name happens in a loop! ``` * #


def customNameConfirmPrompt(inputName):
    return f'''{inputName} for all primary branches?'''


# * ``` Placeholder variable for repository types!``` * #
repoTypes = ""

# * ``` Placeholder variable for local directories selection(s)! ``` * #
localDirectories = True
localDirectory = Path.home()
# ! TESTING # !!
localDirectory = f"{Path.home()}/Code"

# * ``` Placeholder variable for git alias selection! ``` * #
gitNew = True

# * ``` Placeholder variables for the tokens! ``` * #
token = ""
tokenRepoScope = ""
tokenPublicRepoScope = ""

# ! TESTING # !!
with open("./repo.txt", 'r') as repoF:
    tokenRepoScope = repoF.read(40)

# ! TESTING # !!
with open("./repoPublicRepo.txt", 'r') as repoPublicRepoF:
    tokenPublicRepoScope = repoPublicRepoF.read(40)

# // Placeholder variable for the total set of repos, and repoNames and repoUrls!
# [d['value'] for d in l]
# * Placeholder variable for the total set of repos! * #
repos = []
repoNames = []
repoUrls = []

# * Placeholder variable for the set of local repos! * #
localRepos = []

# * ``` Intro text! ``` * #
intro = """
  Welcome to master-blaster! This program renames primary branches for github users!
  We'll go through the options before making any changes!
"""
print(intro)

# * ``` License text! ``` * #
licenseText = """
    master-blaster  Copyright (C) 2020  Gareth Field
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.
"""
print(licenseText)
print("Working on `show w' and `show c', actually! It's GNU public 3+! No closed versions!")

# * ``` Explanation of token thing! ``` * #
tokenExplanation = """
  GitHub is deprecating password-based token generation! This is great for
  security, it's going to mean you're going to have to go to GitHub.com and
  come back with an access token to make this program work, though. The next
  question will determine whether the program needs a token with the more
  general `repo` scope or the more limited `public_repo` scope. You can run
  this program again if you're happy with the results!
"""
print(tokenExplanation)

# * Create a log file, or be ready to write to an existing log file * #
# ! Testing! # !
# filemode='w' will not append to the file, it'll write over
logging.basicConfig(filename='info.log', filemode='w',
                    level=logging.INFO, format='%(asctime)s %(message)s')
print("Log file found at ./info.log!")
logging.info("Creating a log file!!")

# * ~~~ First set of questionary dict questions! ~~~ * #
# * ``` Ask for username! ``` * #
usernamePrompt = """
  Please enter your GitHub username!
"""

# * ``` What types of repos question and choices! ``` * #
repoTypesPrompt = """
  What set of repositories do you want to update?
"""

repoTypesAll = "All repositories I'm the owner, collaborator, and/or organization member, public and private."
repoTypesAllPublic = "All repositories I'm the owner, collaborator, and/or organization member, only public, not private."
repoTypesOwner = "All repositories I'm the owner of, public and private."
repoTypesOwnerPublic = "All repositories I'm the owner of, only public, not private."
repoTypesCollaborator = "All repositories I'm the owner of and/or a collaborator on, public and private."
repoTypesCollaboratorPublic = "All repositories I'm the owner of and/or a collaborator on, only public, not private."
repoTypesOrganization = "All repositories I'm the owner of and/or a member of the organization, public and private."
repoTypesOrganizationPublic = "All repositories I'm the owner of and/or a member of the organization, only public, not private."

# * ``` What to name the primary branches and choices! ``` * #
namesSelectionPrompt = """
  What would you like to call your primary branches? (Default 'main'.)
"""

namesMain = "All primary branches renamed to 'main'."
namesCustom = "Choose another name to rename all primary branches to."
namesPerRepo = "Interactively choose a name for the primary branch for each repo."


# * ``` Custom questionary text! ``` * #
# * ``` Confirmation that interactive naming mode will happen! ``` * #
interactiveNamingConfirmationPrompt = """
    Okay! We'll name them after we fetch the set of repos!
"""
# * ``` Custom name for all branches! ``` * #
customNamePrompt = """
  What name are you choosing for primary branches?
"""
# * ``` Confirm reset to main! ``` * #
confirmResetToMainPrompt = """
    Default: use 'main' for all primary branches?
"""


# * ~~~ Second set of questionary dict questions! ~~~ * #
localDirectoriesPrompt = """
  Repositories not present locally will be cloned to a temporary folder,
  updated, the update pushed, (the default branch on GitHub.com updated,)
  and then deleted locally. We can decrease the use of bandwidth and reduce
  potential conflicts by scanning for repositories that *are* present locally.
  Is this okay? (No other changes will be added or committed.)
"""

localDirectoryPrompt = """
    Do you keep your projects in a certain directory? Type that in here to
    speed up search! Like /Users/gareth/Code ... default is ~/, hit enter for default.
"""

gitNewPrompt = """
  We can add a git alias 'git new' that initializes new git repos with HEAD as
  'main', shall we?
"""

repoPublicRepoTokenPrompt = """
     Last step! Since password-based token generation is being deprecated, please
     get a personal access token with the correct scope(s) in order to run this
     program. To get this token, go to https://github.com, sign in, then go to
     'Settings', then 'Developer Settings', then 'Personal access tokens', then
     'Generate new token', confirm your password, name the token in the 'Note'
     input field, and select the 'public repo' scope, then 'Generate Token', then
     copy it to your clipboard and either paste it back here into the prompt, or
     save it first in case there's an error and you need to retry. (Recommended)
"""

repoTokenPrompt = """
     Last step! Since password-based token generation is being deprecated, please
     get a personal access token with the correct scope(s) in order to run this
     program. To get this token, go to https://github.com, sign in, then go to
     'Settings', then 'Developer Settings', then 'Personal access tokens', then
     'Generate new token', confirm your password, name the token in the 'Note'
     input field, and select the 'repo' scope, then 'Generate Token', then
     copy it to your clipboard and either paste it back here into the prompt, or
     save it first in case there's an error and you need to retry. (Recommended)
"""

questionsOne = [
    {
        "type": "text",
        "name": "username",
        "message": usernamePrompt,
    },
    {
        "type": "select",
        "name": "repoTypes",
        "message": repoTypesPrompt,
        "choices": [
            repoTypesAll,
            repoTypesAllPublic,
            repoTypesOwner,
            repoTypesOwnerPublic,
            repoTypesCollaborator,
            repoTypesCollaboratorPublic,
            repoTypesOrganization,
            repoTypesOrganizationPublic
        ]
    },
    {
        "type": "select",
        "name": "namesSelection",
        "message": namesSelectionPrompt,
        "choices": [
            "All primary branches renamed to 'main'.",
            "Choose another name to rename all primary branches to.",
            "Interactively choose a name for the primary branch for each repo."
        ]
    }
]
answersOne = questionary.prompt(questionsOne)

# * Extract the data from the first set of prompts! * #
username = answersOne['username']
# ! Testing ! #
username = "Twitchkidd"
# ! Testing ! #

repoTypes = answersOne['repoTypes']
logging.info(f"Repo types: {repoTypes}")
logging.info(f"Naming selection: {answersOne['namesSelection']}")

# * Custom questionary flow! * #

if answersOne['namesSelection'] == "Interactively choose a name for the primary branch for each repo.":
    interactive = True
    print(interactiveNamingConfirmationPrompt)

if answersOne['namesSelection'] == "Choose another name to rename all primary branches to.":
    nameConfirmed = False
    while not nameConfirmed:
        customNameResponse = questionary.text(customNamePrompt).ask()
        if customNameResponse == "":
            confirmResetToMainResponse = questionary.confirm(
                confirmResetToMainPrompt).ask()
            if confirmResetToMainResponse:
                name = "main"
                nameConfirmed = True
                logging.info(f"Name for primary branches: {name}")
            else:
                continue
        else:
            confirmCustomNameResponse = questionary.confirm(
                customNameConfirmPrompt(customNameResponse)).ask()
            if confirmCustomNameResponse:
                name = customNameResponse
                nameConfirmed = True
                logging.info(f"Name for primary branches: {name}")
                pass

# * Second set of questions after custom flow required! * #
questionsTwo = [
    {
        "type": "confirm",
        "name": "localDirectories",
        "message": localDirectoriesPrompt
    },
    {
        "type": "text",
        "name": "localDirectory",
        "message": localDirectoryPrompt,
        "when": lambda x: x['localDirectories']
    },
    {
        "type": "confirm",
        "name": "gitNew",
        "message": gitNewPrompt
    },
    {
        "type": "text",
        "name": "repoPublicRepoToken",
        "message": repoPublicRepoTokenPrompt,
        "when": lambda x: repoTypes == "All repositories I'm the owner, collaborator, and/or organization member, only public, not private." or repoTypes == "All repositories I'm the owner of, only public, not private." or repoTypes == "All repositories I'm the owner of and/or a collaborator on, only public, not private." or repoTypes == "All repositories I'm the owner of and/or a member of the organization, only public, not private."
        # "when": lambda x: any(repoTypes in ["All repositories I'm the owner, collaborator, and/or organization member, only public, not private.", "All repositories I'm the owner of, only public, not private.", "All repositories I'm the owner of and/or a collaborator on, only public, not private.", "All repositories I'm the owner of and/or a member of the organization, only public, not private."])
        # why can't I get this work with any()?
    },
    {
        "type": "text",
        "name": "repoToken",
        "message": repoTokenPrompt,
        "when": lambda x: repoTypes == "All repositories I'm the owner, collaborator, and/or organization member, public and private." or repoTypes == "All repositories I'm the owner of, public and private." or repoTypes == "All repositories I'm the owner of and/or a collaborator on, public and private." or repoTypes == "All repositories I'm the owner of and/or a member of the organization, public and private."
    }
]
answersTwo = questionary.prompt(questionsTwo)

# * Extract the data from the second set of prompts! * #
# TODO logging when this gets customized
localDirectories = answersTwo['localDirectories']
if 'localDirectory' in answersTwo and answersTwo['localDirectory'] != "":
    localDirectory = answersTwo['localDirectory']

gitNew = answersTwo['gitNew']
logging.info(f"Add git alias `git new`: {gitNew}")

# * Set the token! * #
if 'repoPublicRepoToken' in answersTwo:
    token = answersTwo['repoPublicRepoToken']
else:
    token = answersTwo['repoToken']
# ! Testing # !
# token = "fermf"
token = tokenRepoScope

# * Check if a token was entered! * #
# TODO More graceful collapse
# TODO logging when this gets customized
# ! Testing # !
# if not answersTwo['repoToken'] or answersTwo['repoPublicRepoToken']:
#     sys.exit('Error: No token detected! Try again please!')

# * ~~~ Constructing the url! ~~~ * #

# * Construct the headers! * #
headers = {"Authorization": 'token ' + token}

# * Custruct the parameters! * #
params = {}
if repoTypes == repoTypesAll:
    params = {"per_page": "1000"}
if repoTypes == repoTypesAllPublic:
    params = {"per_page": "1000", "visibility": "public"}
if repoTypes == repoTypesOwner:
    params = {"per_page": "1000", "type": "owner"}
if repoTypes == repoTypesOwnerPublic:
    params = {"per_page": "1000", "visibility": "public", "type": "owner"}
if repoTypes == repoTypesCollaborator:
    params = {"per_page": "1000", "type": "owner,collaborator"}
if repoTypes == repoTypesCollaboratorPublic:
    params = {"per_page": "1000", "visibility": "public",
              "type": "owner,collaborator"}
if repoTypes == repoTypesOrganization:
    params = {"per_page": "1000",
              "type": "owner,collaborator,organization_member"}
if repoTypes == repoTypesOrganizationPublic:
    params = {"per_page": "1000", "visibility": "public",
              "type": "owner,collaborator,organization_member"}

# * Make the API call! * #
reposResponse = requests.get(
    f"{GITHUB_API}/user/repos", headers=headers, params=params)

# * Bad token returns a 401! * #
# TODO More graceful collapse
# TODO logging when this gets customized
if reposResponse.status_code >= 400:
    sys.exit('Network Error: Possibly the token! Try again please!')

# * Extract the data from the API call! * #
# TODO Not like this ... not like this ...
for repository in reposResponse.json():
    repos.append(
        {"defaultBranch": repository['default_branch'], "htmlUrl": repository['html_url'], "name": repository['name'], "primaryBranchName": name})
    repoNames.append(repository['name'])
    repoUrls.append(repository['html_url'])

# * If they wanted to name each primary branch, do so now! * #
# TODO Confirmation! ... Maybe? Discuss.
if interactive:
    for repo in repos:
        repoName = questionary.text(
            f"Primary branch name for {repo['htmlUrl']}?").ask()
        repo['primaryBranchName'] = repoName

# * Take all these repos and test them against what the name is supposed to be! * #
# TODO Weed out some requests by seeing if they have the branch already (maybe? meta-TODO) or don't have a master
# TODO logging when this gets customized
# /repos/{username}/{repo}/branches/{branch}!
# So we need ... has primaryBranchName on remote, has master on remote ...  and then we do the logic for if they have neither later
for repo in repos:
    primaryBranchResponse = requests.get(
        f"{GITHUB_API}/repos/{username}/{repo['name']}/branches/{repo['primaryBranchName']}", headers=headers)
    masterBranchResponse = requests.get(
        f"{GITHUB_API}/repos/{username}/{repo['name']}/branches/master", headers=headers)
    # if primaryBranchResponse.json()['message'] == "Branch not found":
    #     print(f"No primary branch for {repo['htmlUrl']}")
    # if masterBranchResponse.json()['message'] == "Branch not found":
    #     print(f"No master branch for {repo['htmlUrl']}")
    print(json.dumps(primaryBranchResponse.json()), sort_keys=True, indent=2)
    print(json.dumps(masterBranchResponse.json()), sort_keys=True, indent=2)


def getUrl(configFile):
    url = ""
    for line in configFile:
        if line.find('url =') != -1:
            remoteOriginUrlStart = line.find('url =')
            url = line[remoteOriginUrlStart + 6:-1]
            return url


# * If they wanted to use local clones, this is where we differentiate that set! * #
# TODO logging when this gets customized
if 'localDirectories' in answersTwo:
    for root, subdirs, files in os.walk(f"{localDirectory}"):
        for subdir in subdirs:
            if any(subdir == repoName for repoName in repoNames):
                try:
                    with open(f"{root}/{subdir}/.git/config", "r") as configFile:
                        localRepos.append(
                            {"url": getUrl(configFile), "path": f"{root}/{subdir}"})
                except Exception as err:
                    # ! Testing # !
                    # print(f"Exception: {err}")
                    pass
# ! Testing # !
print(localRepos)

# TODO All of this!
# TODO logging when this gets customized
# * Change the branch! * #
for repo in repos:
    if repo['htmlUrl'] in [localRepo['htmlUrl'] for localRepo in localRepos]:
        # # * MUST REVIEW THE PROTOCOL FOR LOCAL REPOS! * #
        # # Oh, there's a different process for local branches, I think I might have messed up on the other machine, lol
        localProcess(repo['path'])
    else:
        remoteProcess(repo['htmlUrl'])
        # # * THIS IS FOR CHANGING THE GITHUB DEFAULT BRANCH * #
        # # PATCH /repos/:owner/:repo
        # # default_branch? string
        # * requests.patch is a thing! * #


# TODO All of this!
# TODO logging when this gets customized
# * Add the `git new` alias! * #
if gitNew:
    print(gitNew)

# TODO Communicate this!
# TODO Provide a tool!
# * Learning about how this works for multiple systems! * #
# *     When master-blaster is run, * #
# *         any other systems with local clones must run * #
# *             $ git checkout master * #
# *             $ git branch -m master main * #
# *             $ git fetch * #
# *             $ git branch --unset-upstream * #
# *             $ git branch -u origin/main * #
# *             $ git symbolic-ref refs/remotes/origin/HEAD refs/remotes/origin/main * #
# *         Tested: they don't need to push any changes first or even commit them or even add them to staging! * #
# * Also, should I be testing if the repo already has a remote branch main? That it's the default branch? * #
# * Oooh, okay, so capture default branch when you get the initial list of repos back, * #
# * And then you only need to ... well search for any the same way, but if you get a difference between the * #
# * remote value and the local value, you'll have to handle that ... * #

# TODO Next up!
# TODO How to check for there being a local branch master/main/what the default is?
# * Step 1! Check if remote branches exist with GET /repos/{username}/{repo}/branches/{branch}! * #
# * Error returns { * #
# *   "message": "Branch not found", * #
# *   "documentation_url": "https://developer.github.com/v3/repos/branches/#get-branch" * #
# * } * #

# * ... Okay so after the first request is made ... Which we should probably be handling errors for, lol! * #

# * Anyway, then the possible interactive naming happens, and then you have every * #

# TODO Only go through the base move and push if local and remote branches are master!
# TODO Handle all other cases somehow, but this seems like where you REALLY need the error checking.
