#!/usr/bin/env python

# Master Blaster - Rename Primary Branches Of Code Repositories
# Copyright (C) 2020 Gareth Field - field.gareth @ gmail.com

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import questionary
import requests
import json
from pathlib import Path
import os

# This defaults to v3 of the api.
GITHUB_API = "https://api.github.com"

# * ``` Placeholder variable for the name(s)! ```
name = "main"
names = {}

# * ``` Placeholder variable for repository types! ```
repoTypes = ""

# * ``` Placeholder variable for names selection! ```
namesSelection = ""

# * ``` Placeholder variable for local directories selection! ```
localDirectories = True

# * ``` Placeholder variable for git alias selection! ```
gitNew = True

# * ``` Placeholder variables for the tokens! ```
token = ""
tokenRepoScope = ""
tokenPublicRepoScope = ""

# ! TESTING!
with open("./repo.txt", 'r') as repoF:
    tokenRepoScope = repoF.read(40)

# ! TESTING!
with open("./repoPublicRepo.txt", 'r') as repoPublicRepoF:
    tokenPublicRepoScope = repoPublicRepoF.read(40)

# * Placeholder variable for the set of repos!
repos = []

# * ``` Intro text! ```
intro = """
  Welcome to master-blaster! This program renames primary branches for github users!
  We'll go through the options before making any changes!
"""
print(intro)

# * ``` License text! ```
licenseText = """
    master-blaster  Copyright (C) 2020  Gareth Field
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.
"""
print(licenseText)

# * ``` Explanation of token thing! ```
tokenExplanation = """
  GitHub is deprecating password-based token generation! This is great for
  security, it's going to mean you're going to have to go to GitHub.com and
  come back with an access token to make this program work, though. The next
  question will determine whether the program needs a token with the more
  general `repo` scope or the more limited `public_repo` scope. You can run
  this program again if you're happy with the results!
"""
print(tokenExplanation)

# * ~~~ First set of questionary dict questions! ~~~

# * ``` Ask for username! ```
usernamePrompt = """
  Please enter your GitHub username!
"""

# * ``` What types of repos question and choices! ```
repoTypesPrompt = """
  What set of repositories do you want to update?
"""

repoTypesAll = "All repositories I'm the owner, collaborator, and/or organization member, public and private."
repoTypesAllPublic = "All repositories I'm the owner, collaborator, and/or organization member, only public, not private."
repoTypesOwner = "All repositories I'm the owner of, public and private."
repoTypesOwnerPublic = "All repositories I'm the owner of, only public, not private."
repoTypesCollaborator = "All repositories I'm the owner of and/or a collaborator on, public and private."
repoTypesCollaboratorPublic = "All repositories I'm the owner of and/or a collaborator on, only public, not private."
repoTypesOrganization = "All repositories I'm the owner of and/or a member of the organization, public and private."
repoTypesOrganizationPublic = "All repositories I'm the owner of and/or a member of the organization, only public, not private."

# * ``` What to name the primary branches and choices! ```
namesSelectionPrompt = """
  What would you like to call your primary branches? (Default 'main'.)
"""

namesMain = "All primary branches renamed to 'main'."
namesCustom = "Choose another name to rename all primary branches to."
namesPerRepo = "Interactively choose a name for the primary branch for each repo."

# * ``` Custom name for all branches! ```
customNamePrompt = """
  What name are you choosing for primary branches?
"""

# * ``` Confirmation that interactive naming mode will happen! ```
# TODO Make interactive naming mode happen ...
interactiveNamingConfirmPrompt = """
    Okay! We'll name them after we fetch the set of repos!
"""

# * ~~~ Second set of questionary dict questions! ~~~


localDirectoriesPrompt = """
  Repositories not present locally will be cloned to a temporary folder,
  updated, the update pushed, (the default branch on GitHub.com updated,)
  and then deleted locally. We can decrease the use of bandwidth and reduce
  potential conflicts by scanning for repositories that *are* present locally.
  Is this okay? (No other changes will be added or committed.)
"""

gitNewPrompt = """
  We can add a git alias 'git new' that initializes new git repos with HEAD as
  'main', shall we?
"""

repoPublicRepoTokenPrompt = """
     Last step! Since password-based token generation is being deprecated, please
     get a personal access token with the correct scope(s) in order to run this
     program. To get this token, go to https://github.com, sign in, then go to
     'Settings', then 'Developer Settings', then 'Personal access tokens', then
     'Generate new token', confirm your password, name the token in the 'Note'
     input field, and select the 'public repo' scope, then 'Generate Token', then
     copy it to your clipboard and either paste it back here into the prompt, or
     save it first in case there's an error and you need to retry. (Recommended)
"""

repoTokenPrompt = """
     Last step! Since password-based token generation is being deprecated, please
     get a personal access token with the correct scope(s) in order to run this
     program. To get this token, go to https://github.com, sign in, then go to
     'Settings', then 'Developer Settings', then 'Personal access tokens', then
     'Generate new token', confirm your password, name the token in the 'Note'
     input field, and select the 'repo' scope, then 'Generate Token', then
     copy it to your clipboard and either paste it back here into the prompt, or
     save it first in case there's an error and you need to retry. (Recommended)
"""

questionsOne = [
    {
        "type": "text",
        "name": "username",
        "message": usernamePrompt,
    },
    {
        "type": "select",
        "name": "repoTypes",
        "message": repoTypesPrompt,
        "choices": [
            repoTypesAll,
            repoTypesAllPublic,
            repoTypesOwner,
            repoTypesOwnerPublic,
            repoTypesCollaborator,
            repoTypesCollaboratorPublic,
            repoTypesOrganization,
            repoTypesOrganizationPublic
        ]
    },
    {
        "type": "select",
        "name": "namesSelection",
        "message": namesSelectionPrompt,
        "choices": [
            "All primary branches renamed to 'main'.",
            "Choose another name to rename all primary branches to.",
            "Interactively choose a name for the primary branch for each repo."
        ]
    },
    {
        "type": "text",
        "name": "customName",
        "message": customNamePrompt,
        "when": lambda x: x['namesSelection'] == "Choose another name to rename all primary branches to."
    },
    {
        "type": "confirm",
        "name": "interactiveNamingConfirm",
        "message": interactiveNamingConfirmPrompt,
        "when": lambda x: x['namesSelection'] == "Interactively choose a name for the primary branch for each repo."
    }
]
answersOne = questionary.prompt(questionsOne)

# * Extract the data from the first set of prompts!
username = answersOne['username']
# ! TESTING!
username = "Twitchkidd"

repoTypes = answersOne['repoTypes']
namesSelection = answersOne['namesSelection']

# * Custom questionary flow!


def customNameConfirmPrompt(inputName):
    name = inputName
    return f'''{inputName} for all primary branches?'''


if 'customName' in answersOne:
    name = answersOne['customName']
    nameConfirmed = False
    while not nameConfirmed:
        response = questionary.confirm(
            customNameConfirmPrompt(name)).ask()
        if not response:
            newName = questionary.text(customNamePrompt).ask()
            newNameResponse = questionary.confirm(
                customNameConfirmPrompt(newName)
            ).ask()
        if response:
            nameConfirmed = True


# * Second set of questions after custom flow required!
questionsTwo = [
    {
        "type": "confirm",
        "name": "localDirectories",
        "message": localDirectoriesPrompt
    },
    {
        "type": "confirm",
        "name": "gitNew",
        "message": gitNewPrompt
    },
    {
        "type": "text",
        "name": "repoPublicRepoToken",
        "message": repoPublicRepoTokenPrompt,
        "when": lambda x: repoTypes == "All repositories I'm the owner, collaborator, and/or organization member, only public, not private." or repoTypes == "All repositories I'm the owner of, only public, not private." or repoTypes == "All repositories I'm the owner of and/or a collaborator on, only public, not private." or repoTypes == "All repositories I'm the owner of and/or a member of the organization, only public, not private."
        # "when": lambda x: any(repoTypes in ["All repositories I'm the owner, collaborator, and/or organization member, only public, not private.", "All repositories I'm the owner of, only public, not private.", "All repositories I'm the owner of and/or a collaborator on, only public, not private.", "All repositories I'm the owner of and/or a member of the organization, only public, not private."])
        # why can't I get this work with any()?
    },
    {
        "type": "text",
        "name": "repoToken",
        "message": repoTokenPrompt,
        "when": lambda x: repoTypes == "All repositories I'm the owner, collaborator, and/or organization member, public and private." or repoTypes == "All repositories I'm the owner of, public and private." or repoTypes == "All repositories I'm the owner of and/or a collaborator on, public and private." or repoTypes == "All repositories I'm the owner of and/or a member of the organization, public and private."
    }
]
answersTwo = questionary.prompt(questionsTwo)

# * Extract the data from the second set of prompts!
localDirectories = answersTwo['localDirectories']
gitNew = answersTwo['gitNew']

if 'repoPublicRepoToken' in answersTwo:
    token = answersTwo['repoPublicRepoToken']
else:
    token = answersTwo['repoToken']

# ! TESTING!
token = tokenRepoScope

# * ~~~ Constructing the url! ~~~

# * Construct the headers!
headers = {"Authorization": 'token ' + token}

# * Custruct the parameters!
params = {}
if repoTypes == repoTypesAll:
    params = {"per_page": "1000"}
if repoTypes == repoTypesAllPublic:
    params = {"per_page": "1000", "visibility": "public"}
if repoTypes == repoTypesOwner:
    params = {"per_page": "1000", "type": "owner"}
if repoTypes == repoTypesOwnerPublic:
    params = {"per_page": "1000", "visibility": "public", "type": "owner"}
if repoTypes == repoTypesCollaborator:
    params = {"per_page": "1000", "type": "owner,collaborator"}
if repoTypes == repoTypesCollaboratorPublic:
    params = {"per_page": "1000", "visibility": "public",
              "type": "owner,collaborator"}
if repoTypes == repoTypesOrganization:
    params = {"per_page": "1000",
              "type": "owner,collaborator,organization_member"}
if repoTypes == repoTypesOrganizationPublic:
    params = {"per_page": "1000", "visibility": "public",
              "type": "owner,collaborator,organization_member"}

# * Make the API call!
reposResponse = requests.get(
    f"{GITHUB_API}/user/repos", headers=headers, params=params)

# * Extract the data from the API call!
for repository in reposResponse.json():
    print(json.dumps(repository, indent=2, sort_keys=True))
    repos.append(
        {"htmlUrl": repository['html_url'], "name": repository['name'], "primaryBranchName": name})

if 'interactiveNamingConfirm' in answersOne:
    for repo in repos:
        repoName = questionary.text(
            f"Primary branch name for {repo['htmlUrl']}?").ask()
        repo['primaryBranchName'] = repoName
print(repos)

# # * THIS PART IS WHERE WE SEARCH FOR LOCAL REPOS AND COMPARE AGAINST REPOS ON GITHUB
# localRepoNames = []
# localRepos = []
# # for root, subdirs, files in os.walk(Path.home()):
# for root, subdirs, files in os.walk(f"{Path.home()}/Code"):
#     for d in subdirs:
#         if any(d == name for name in repos):
#             for root2, subdirs2, files2 in os.walk(f"{root}/{d}"):
#                 if ".git" in subdirs2:
#                     localRepos.append(f"{root}/{d}")
#                     localRepoNames.append(d)
#                     # * okay so {subdirs2}/.git/config after [remote "origin"] \n url = contains the remoteorigin url
# print(sorted(localRepoNames))
# print(len(localRepoNames))

# # * requests.patch is a thing!

# # * THIS IS AN EXAMPLE OF READING FILES, GOING TO HAVE TO DO KINDA LIKE THIS FOR THE ORIGIN IN GIT DIRS!
# # email = ""
# # emailStringStart = 0
# # if checkGitconfig == "Yes":
# #     print("Okay ")
# #     with open(f"{Path.home()}/.gitconfig", 'r') as f:
# #         # gitconfig = f.read()
# #         # print(gitconfig)
# #         found = False
# #         for line in f:
# #             if line.find("email =") != -1:
# #                 print(line)
# #                 found = True
# #                 emailStringStart = line.find("email =")
# #                 print(line[emailStringStart + 8:])
# #         if found == False:
# #             print("Can't find email!")

# # * THIS IS FOR CHANGING THE GITHUB DEFAULT BRANCH
# # PATCH /repos/:owner/:repo
# # default_branch? string

# # * THIS MIGHT BE A BETTER WAY OF MAKING THIS SCRIPT EXECUTABLE!
# # __main__ — Top-level script environment¶
# # '__main__' is the name of the scope in which top-level code executes. A module’s __name__ is set equal to '__main__' when read from standard input, a script, or from an interactive prompt.

# # A module can discover whether or not it is running in the main scope by checking its own __name__, which allows a common idiom for conditionally executing code in a module when it is run as a script or with python -m but not when it is imported:

# # if __name__ == "__main__":
# #     # execute only if run as a script
# #     main()
# # For a package, the same effect can be achieved by including a __main__.py module, the contents of which will be executed when the module is run with -m.

# # * MUST REVIEW THE PROTOCOL FOR LOCAL REPOS!
# # Oh, there's a different process for local branches, I think I might have messed up on the other machine, lol
