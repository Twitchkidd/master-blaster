#!/usr/bin/env python

# Master Blaster - Rename Primary Branches Of Code Repositories
# Copyright (C) 2020 Gareth Field - field.gareth @ gmail.com

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import questionary
from pathlib import Path
import requests
import json
from urllib.parse import urljoin

GITHUB_API = "https://api.github.com"

repo = ""
repoPublicRepo = ""

with open("./repo.txt", 'r') as repoF:
  repo = repoF.read(40)

with open("./repoPublicRepo.txt", 'r') as repoPublicRepoF:
  repoPublicRepo = repoPublicRepoF.read(40)

intro = """
  Welcome to master-blaster! This program renames primary branches for github users!
  We'll go through the options before making any changes!
"""

print(intro)

licenseText = """
  TODO PRINT LICENSE
"""

print(licenseText)

tokenExplanation = """
  GitHub is deprecating password-based token generation! This is great for
  security, it's going to mean you're going to have to go to GitHub.com and
  come back with an access token to make this program work, though. The next
  question will determine whether the program needs a token with the more
  general `repo` scope or the more limited `public_repo` scope. You can run
  this program again if you're happy with the results
"""

print(tokenExplanation)

usernamePrompt = """
  Please enter your GitHub username!
"""

repoTypesPrompt = """
  What set of repositories do you want to update?
"""

# repoTypesAll = "All repositories I'm the owner, collaborator, and/or organization member, public and private."
# repoTypesAllPublic = "All repositories I'm the owner, collaborator, and/or organization member, only public, not private."
# repoTypesOwner = "All repositories I'm the owner of, public and private."
# repoTypesOwnerPublic = "All repositories I'm the owner of, only public, not private."
# repoTypesCollaborator = "All repositories I'm the owner of and/or a collaborator on, public and private."
# repoTypesCollaboratorPublic = "All repositories I'm the owner of and/or a collaborator on, only public, not private."
# repoTypesOrganization = "All repositories I'm the owner of and/or a member of the organization, public and private."
# repoTypesOrganizationPublic = "All repositories I'm the owner of and/or a member of the organization, only public, not private."

namesPrompt = """
  What would you like to call your primary branches? (We recommend 'main'.)
"""

namesMain = "All primary branches renamed to 'main'."
namesCustom = "Choose another name to rename all primary branches to."
namesPerRepo = "Interactively choose a name for the primary branch for each repo."

localDirectoriesPrompt = """
  Repositories not present locally will be cloned to a temporary folder,
  updated, the update pushed, (the default branch on GitHub.com updated,)
  and then deleted locally. We can decrease the use of bandwidth and reduce
  potential conflicts by scanning for repositories that *are* present locally.
  Is this okay? (No other changes will be added or committed.)
"""

gitNewPrompt = """
  We can add a git alias 'git new' that initializes new git repos with HEAD as
  'main', shall we?
"""

def tokenFetchPrompt(scopes):
  return f"""
    Last step! Since password-based token generation is being deprecated, please
    get a personal access token with the correct scope(s) in order to run this
    program. To get this token, go to https://github.com, sign in, then go to
    'Settings', then 'Developer Settings', then 'Personal access tokens', then
    'Generate new token', confirm your password, name the token in the 'Note'
    input field, and select the {scopes} scope(s), then 'Generate Token', then
    copy it to your clipboard and either paste it back here into the prompt, or
    save it first in case there's an error and you need to retry. (Recommended)
  """

questions = [
  {
    "type": "text",
    "name": "username",
    "message": usernamePrompt
  },
  {
    "type": "select",
    "name": "repoTypes",
    "message": repoTypesPrompt,
    "choices": [
      "All repositories I'm the owner, collaborator, and/or organization member, public and private.",
      "All repositories I'm the owner, collaborator, and/or organization member, only public, not private.",
      "All repositories I'm the owner of, public and private.",
      "All repositories I'm the owner of, only public, not private.",
      "All repositories I'm the owner of and/or a collaborator on, public and private.",
      "All repositories I'm the owner of and/or a collaborator on, only public, not private.",
      "All repositories I'm the owner of and/or a member of the organization, public and private.",
      "All repositories I'm the owner of and/or a member of the organization, only public, not private."
    ]
  },
  {
    "type": "select",
    "name": "names",
    "message": namesPrompt,
    "choices": [
      "All primary branches renamed to 'main'.",
      "Choose another name to rename all primary branches to.",
      "Interactively choose a name for the primary branch for each repo."
    ]
  },
  {
    "type": "confirm",
    "name": "localDirectories",
    "message": localDirectoriesPrompt
  },
  {
    "type": "confirm",
    "name": "gitNew",
    "message": gitNewPrompt
  },
  {
    "type": "text",
    "name": "token",
    "message": tokenFetchPrompt("SCOPE TODO")
  }
]

answers = questionary.prompt(questions)

print(answers)
# url = urljoin(GITHUB_API, 'authorizations')
# res = requests.get(

# )
# print(res.json())


# requests.patch is a thing!

# init = '''
# Welcome to master-blaster! This program automatically renames primary branches
# from master to main for GitHub users!
# '''

# username = input("GitHub username: ")
# password = getpass.getpass("GitHub password: ")

# url = urljoin(GITHUB_API, 'authorizations')
# payload = {}

# res = requests.post(
#     url,
#     auth=(username, password),
#     data=json.dumps(payload)
# )

# j = json.loads(res.text)
# if res.status_code >= 400:
#     msg = j.get('message', "UNDEFINED ERROR (no error description from server)")
#     print(f"Error: {msg}")
#     exit()
# token = j["token"]
# print(f"Token : {token}")

# answer = questionary.select(
#     "prompt",
#     choices=[
#         "Option 1",
#         "Option 2",
#         "Option 3"
#     ]
# ).ask()
# prompt = "Check ~/.gitconfig for your GitHub email? "
# checkGitconfig = input(prompt)
# print(checkGitconfig)
# email = ""
# emailStringStart = 0
# if checkGitconfig == "Yes":
#     print("Okay ")
#     with open(f"{Path.home()}/.gitconfig", 'r') as f:
#         # gitconfig = f.read()
#         # print(gitconfig)
#         found = False
#         for line in f:
#             if line.find("email =") != -1:
#                 print(line)
#                 found = True
#                 emailStringStart = line.find("email =")
#                 print(line[emailStringStart + 8:])
#         if found == False:
#             print("Can't find email!")
# Uhh so, turns out you can't search by email, as that's not a public thing. Wah wah. Lots to learn.
# So username is what we're looking for ... and how to generate an oauth token? I was looking at
# oauth apps, but you can just hit the rest api with an authorization header that's an oauth token

# Oh thank the l ... thanks Jason McVetta!!! https://advanced-python.readthedocs.io/en/latest/rest/authtoken.html

# Oh, fuck me! GitHub is nuking password-based token generation! Doesn't work without 2FA! UMMM okay, either
# ask the user to generate a token manually or launch a browser somehow?!


# Okay so we'll need something explaining what you need to come back to the terminal with
# and an input it paste in the token
# and then the rest of the questions which go
# username
# types of repos ... actually does that need to go in before the ... yea, because you need
# to explain what scope to allow ...
# yea lets see, scope ... so ...
# username,
# what types of repos ... so it looks like either `repo` or `public_repo`
# I guess I don't need to go crazy with specification of single or multiple contributer-type stuff yet
# then when you have username and what scopes to ask for, then ... ping for the list, and if
# that goes wrong there was either a username or scope issue, and for the moment just close the process?
# Okay well once you get a list, then ask about what to name the main branches, and say you'll ask that
# beforehand ... and then ask for permission to scan for local repos, warn about committing everything,
# and then do the thing, lol.

# GET /user/repos

# visibility? => all ~ public ~ private
# affiliation? => owner ~ collaborator ~ organization_member
# type? => all ~ owner ~ public ~ private ~ member (422 error if collision with previous)

# PATCH /repos/:owner/:repo
# default_branch? string

# HHMMMM
# __main__ — Top-level script environment¶
# '__main__' is the name of the scope in which top-level code executes. A module’s __name__ is set equal to '__main__' when read from standard input, a script, or from an interactive prompt.

# A module can discover whether or not it is running in the main scope by checking its own __name__, which allows a common idiom for conditionally executing code in a module when it is run as a script or with python -m but not when it is imported:

# if __name__ == "__main__":
#     # execute only if run as a script
#     main()
# For a package, the same effect can be achieved by including a __main__.py module, the contents of which will be executed when the module is run with -m.

# headers = {"user-agent": "my-app-101"}
# payload = { "key1": "Value1", "key2": "Value2"}
# r = requests.whatever("url://something", params=payload)
